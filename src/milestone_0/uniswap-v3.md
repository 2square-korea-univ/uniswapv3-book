## Uniswap V3 소개

> 이 장에서는 [Uniswap V3 백서](https://uniswap.org/whitepaper-v3.pdf)를 다시 설명합니다. 모든 개념을 이해하지 못해도 괜찮습니다. 코드로 변환될 때 더 명확해질 것입니다.

Uniswap V3가 가져온 혁신을 더 잘 이해하기 위해 먼저 Uniswap V2의 불완전성을 살펴보겠습니다.

Uniswap V2는 단일 AMM 알고리즘을 구현하는 일반적인 거래소입니다. 그러나 모든 거래 쌍이 동일한 것은 아닙니다. 쌍은 가격 변동성에 따라 그룹화할 수 있습니다.

1. 중간 및 높은 가격 변동성을 가진 토큰. 이 그룹은 대부분의 토큰을 포함합니다. 왜냐하면 대부분의 토큰은 가격이 고정되어 있지 않고 시장 변동에 영향을 받기 때문입니다.
2. 낮은 변동성을 가진 토큰. 이 그룹에는 페깅된 토큰, 주로 스테이블 코인이 포함됩니다. USDC/USDT, USDC/DAI, USDT/DAI 등입니다. 또한 ETH/stETH, ETH/rETH (랩핑된 ETH의 변형)도 포함됩니다.

이러한 그룹은 서로 다른, 소위 말하는 풀 구성을 필요로 합니다. 주요 차이점은 페깅된 토큰은 큰 거래에서 수요 효과(이전 장에서 배움)를 줄이기 위해 높은 유동성이 필요하다는 것입니다. USDC와 USDT의 가격은 구매 및 판매하려는 토큰 수에 관계없이 1에 가까워야 합니다. Uniswap V2의 일반적인 AMM 알고리즘은 스테이블 코인 거래에 적합하지 않기 때문에 대체 AMM (주로 [Curve](https://curve.fi))이 스테이블 코인 거래에 더 많이 사용되었습니다.

이 문제의 원인은 Uniswap V2 풀의 유동성이 무한히 분산되어 있다는 것입니다. 풀 유동성은 0에서 무한대까지 모든 가격에서 거래를 허용합니다.



![곡선은 무한합니다](images/curve_infinite.png)

이것이 나쁜 것처럼 보이지 않을 수도 있지만, 자본 비효율성을 야기합니다. 자산의 과거 가격은 좁든 넓든 정의된 범위 내에 머무릅니다. 예를 들어, ETH의 과거 가격 범위는 $0.75에서 $4,800입니다([CoinMarketCap](https://coinmarketcap.com/currencies/ethereum/) 기준). 오늘(2022년 6월, 1 ETH는 \$1,800), 아무도 \$5000에 1 이더를 사지 않을 것이므로 이 가격에서 유동성을 제공하는 것은 의미가 없습니다. 따라서 현재 가격에서 멀리 떨어져 있거나 결코 도달하지 않을 가격 범위에서 유동성을 제공하는 것은 의미가 없습니다.

> 하지만, 우리는 모두 ETH가 언젠가 \$10,000에 도달할 것이라고 믿습니다.

## 집중된 유동성

Uniswap V3는 *집중된 유동성*을 도입했습니다. 유동성 공급자는 이제 유동성을 제공하려는 가격 범위를 선택할 수 있습니다. 이는 좁은 가격 범위에 더 많은 유동성을 투입할 수 있도록 하여 자본 효율성을 향상시키고, Uniswap을 더욱 다양하게 만듭니다. 이제 다양한 변동성을 가진 쌍에 대해 풀을 구성할 수 있습니다. 이것이 V3가 V2를 개선하는 방식입니다.

간단히 말해서, Uniswap V3 쌍은 여러 개의 작은 Uniswap V2 쌍입니다. V2와 V3의 주요 차이점은 V3에서는 하나의 쌍에 **많은 가격 범위**가 있다는 것입니다. 그리고 이러한 각 짧은 가격 범위는 **유한한 준비금**을 가지고 있습니다. 0에서 무한대까지의 전체 가격 범위는 더 짧은 가격 범위로 분할되며, 각 범위는 자체 유동성 양을 갖습니다. 하지만 중요한 것은 그 짧은 가격 범위 내에서는 **Uniswap V2와 정확히 동일하게 작동**한다는 것입니다. 이것이 제가 V3 쌍이 여러 개의 작은 V2 쌍이라고 말하는 이유입니다.

이제 시각화해 보겠습니다. 우리가 말하는 것은 곡선이 무한하지 않기를 바란다는 것입니다. 우리는 곡선을 점 $a$와 $b$에서 자르고 이들이 곡선의 경계라고 말합니다. 또한 경계가 축에 놓이도록 곡선을 이동합니다. 이것이 우리가 얻는 것입니다.



![Uniswap V3 가격 범위](images/curve_finite.png)

> 외로워 보이지 않나요? 이것이 Uniswap V3에 많은 가격 범위가 있는 이유입니다. 외롭지 않도록요 🙂

이전 장에서 보았듯이 토큰을 사고파는 것은 가격을 곡선을 따라 이동시킵니다. 가격 범위는 가격 이동을 제한합니다. 가격이 어느 한 지점으로 이동하면 풀은 **고갈**됩니다. 토큰 준비금 중 하나가 0이 되고, 이 토큰을 구매하는 것은 불가능해집니다.

위 차트에서 시작 가격이 곡선의 중간에 있다고 가정해 보겠습니다. 점 $a$에 도달하려면 사용 가능한 모든 $y$를 구매하고 범위 내에서 $x$를 최대화해야 합니다. 점 $b$에 도달하려면 사용 가능한 모든 $x$를 구매하고 범위 내에서 $y$를 최대화해야 합니다. 이러한 지점에서는 범위 내에 토큰이 하나만 있습니다!

> 재미있는 사실: 이것은 Uniswap V3 가격 범위를 지정가 주문으로 사용할 수 있게 합니다!

거래 중에 현재 가격 범위가 고갈되면 어떻게 될까요? 가격은 다음 가격 범위로 미끄러집니다. 다음 가격 범위가 없으면 거래는 부분적으로만 완료됩니다. 이 작동 방식은 책의 뒷부분에서 살펴보겠습니다.

다음은 [실제 USDC/ETH 풀](https://info.uniswap.org/#/pools/0x8ad599c3a0ff1de082011efddc58f1908eb6e6d8)에서 유동성이 분산되는 방식입니다.



![실제 USDC/ETH 풀의 유동성](images/usdceth_liquidity.png)

현재 가격 주변에 많은 유동성이 있지만, 가격에서 멀어질수록 유동성이 줄어드는 것을 볼 수 있습니다. 이는 유동성 공급자가 자본 효율성을 높이기 위해 노력하기 때문입니다. 또한 전체 범위가 무한하지 않고, 상한선이 이미지에 표시됩니다.

## Uniswap V3의 수학

수학적으로 Uniswap V3는 V2를 기반으로 합니다. 동일한 공식을 사용하지만... *확장*되었다고 부르겠습니다.

가격 범위 간 전환을 처리하고, 유동성 관리를 단순화하고, 반올림 오류를 피하기 위해 Uniswap V3는 다음과 같은 새로운 개념을 사용합니다.

$$L = \sqrt{xy}$$

$$\sqrt{P} = \sqrt{\frac{y}{x}}$$

$L$은 *유동성 양*입니다. 풀의 유동성은 토큰 준비금의 조합(즉, 두 숫자)입니다. 우리는 그들의 곱이 $k$라는 것을 알고 있으며, 이것을 사용하여 유동성 측정을 유도할 수 있습니다. 그것은 $\sqrt{xy}$입니다. 제곱하면 $k$와 같아지는 숫자입니다. $L$은 $x$와 $y$의 기하 평균입니다.

$y/x$는 토큰 1에 대한 토큰 0의 가격입니다. 풀의 토큰 가격은 서로 역수이므로 계산에 하나만 사용할 수 있습니다(그리고 관례상 Uniswap V3는 $y/x$를 사용합니다). 토큰 0에 대한 토큰 1의 가격은 단순히 $\frac{1}{y/x}=\frac{x}{y}$입니다. 마찬가지로, $\frac{1}{\sqrt{P}} = \frac{1}{\sqrt{y/x}} = \sqrt{\frac{x}{y}}$입니다.

$p$ 대신 $\sqrt{p}$를 사용하는 이유는 두 가지입니다.

1. 제곱근 계산은 정확하지 않고 반올림 오류를 유발합니다. 따라서 계약에서 계산하지 않고 제곱근을 저장하는 것이 더 쉽습니다(계약에 $x$와 $y$를 저장하지 않을 것입니다).
2. $\sqrt{P}$는 $L$과 흥미로운 관계를 가지고 있습니다. $L$은 출력량 변화와 $\sqrt{P}$ 변화 사이의 관계이기도 합니다.

    $$L = \frac{\Delta y}{\Delta\sqrt{P}}$$

> 증명:
$$L = \frac{\Delta y}{\Delta\sqrt{P}}$$
$$\sqrt{xy} = \frac{y_1 - y_0}{\sqrt{P_1} - \sqrt{P_0}}$$
$$\sqrt{xy} (\sqrt{P_1} - \sqrt{P_0}) = y_1 - y_0$$
$$\sqrt{xy} (\sqrt{\frac{y_1}{x_1}} - \sqrt{\frac{y_0}{x_0}}) = y_1 - y_0$$
$$\textrm{Since } \sqrt{x_1y_1} = \sqrt{x_0y_0} = \sqrt{xy} = L,$$
$$\sqrt{\frac{x_1y_1y_1}{x_1}} - \sqrt{\frac{x_0y_0y_0}{x_0}} = y_1 - y_0$$
$$\sqrt{y_1^2} - \sqrt{y_0^2} = y_1 - y_0$$
$$y_1 - y_0 = y_1 - y_0$$

## 가격 책정

다시 말하지만, 실제 가격을 계산할 필요는 없습니다. 출력량을 바로 계산할 수 있습니다. 또한 $x$와 $y$를 추적하고 저장하지 않으므로 계산은 $L$과 $\sqrt{P}$만을 기반으로 합니다.

위의 공식에서 $\Delta y$를 찾을 수 있습니다.

$$\Delta y = \Delta \sqrt{P} L$$

> 위의 증명에서 세 번째 단계를 참조하십시오.

위에서 논의한 바와 같이 풀의 가격은 서로 역수입니다. 따라서 $\Delta x$는 다음과 같습니다.

$$\Delta x = \Delta \frac{1}{\sqrt{P}} L$$

$L$과 $\sqrt{P}$를 사용하면 풀 준비금을 저장하고 업데이트할 필요가 없습니다. 또한 $\sqrt{P}$를 매번 계산할 필요도 없습니다. 왜냐하면 항상 $\Delta \sqrt{P}$와 그 역수를 찾을 수 있기 때문입니다.

## 틱

이 장에서 배웠듯이 V2의 무한 가격 범위는 V3에서 더 짧은 가격 범위로 분할됩니다. 이러한 각 짧은 가격 범위는 경계(상한 및 하한 지점)로 제한됩니다. 이러한 경계의 좌표를 추적하기 위해 Uniswap V3는 *틱*을 사용합니다.



![가격 범위 및 틱](images/ticks_and_ranges.png)

V3에서 전체 가격 범위는 균등하게 분산된 이산 틱으로 구분됩니다. 각 틱은 인덱스를 가지며 특정 가격에 해당합니다.

$$p(i) = 1.0001^i$$

여기서 $p(i)$는 틱 $i$에서의 가격입니다. 1.0001의 거듭제곱을 취하는 것은 바람직한 속성을 가집니다. 인접한 두 틱 사이의 차이는 0.01% 또는 *1 베이시스 포인트*입니다.

> 베이시스 포인트(1/100th of 1%, 또는 0.01%, 또는 0.0001)는 금융에서 백분율을 측정하는 단위입니다. 중앙 은행이 금리 변경을 발표할 때 베이시스 포인트에 대해 들어봤을 것입니다.

위에서 논의한 바와 같이 Uniswap V3는 $P$가 아닌 $\sqrt{P}$를 저장합니다. 따라서 실제 공식은 다음과 같습니다.

$$\sqrt{p(i)} = \sqrt{1.0001}^i = 1.0001 ^{\frac{i}{2}}$$

따라서 $\sqrt{p(0)} = 1$, $\sqrt{p(1)} = \sqrt{1.0001} \approx 1.00005$, $\sqrt{p(-1)} \approx 0.99995$와 같은 값을 얻습니다.

틱은 양수와 음수일 수 있는 정수이며, 물론 무한하지 않습니다. Uniswap V3는 $\sqrt{P}$를 고정 소수점 Q64.96 숫자로 저장합니다. 이는 정수 부분에 64비트, 소수 부분에 96비트를 사용하는 유리수입니다. 따라서 가격($\sqrt{P}$의 제곱과 같음)은 $[2^{-128}, 2^{128}]$ 범위 내에 있습니다. 그리고 틱은 다음 범위 내에 있습니다.

$$[log_{1.0001}2^{-128}, log_{1.0001}{2^{128}}] = [-887272, 887272]$$

> Uniswap V3의 수학에 대해 더 자세히 알아보려면 [Atis Elsts](https://twitter.com/atiselsts)의 [기술 노트](https://atiselsts.github.io/pdfs/uniswap-v3-liquidity-math.pdf)를 추천하지 않을 수 없습니다.